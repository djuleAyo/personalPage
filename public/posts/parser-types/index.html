<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Parser types · djuleayo
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="djuleayo">
<meta name="description" content="
  Parser types
  
    
    Link to heading
  


  Intro — formal languages and parsing
  
    
    Link to heading
  

All programming languages are specified by a grammar. A grammar tells us whether a piece of text is a valid sentence in that language. A parser generator can take such a grammar and produce a parser. Parsing is the “front end” of compilation: it turns raw text into structure. That’s the basis of how formal languages work.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Parser types">
  <meta name="twitter:description" content="Parser types Link to heading Intro — formal languages and parsing Link to heading All programming languages are specified by a grammar. A grammar tells us whether a piece of text is a valid sentence in that language. A parser generator can take such a grammar and produce a parser. Parsing is the “front end” of compilation: it turns raw text into structure. That’s the basis of how formal languages work.">

<meta property="og:url" content="http://www.example.com/posts/parser-types/">
  <meta property="og:site_name" content="djuleayo">
  <meta property="og:title" content="Parser types">
  <meta property="og:description" content="Parser types Link to heading Intro — formal languages and parsing Link to heading All programming languages are specified by a grammar. A grammar tells us whether a piece of text is a valid sentence in that language. A parser generator can take such a grammar and produce a parser. Parsing is the “front end” of compilation: it turns raw text into structure. That’s the basis of how formal languages work.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-24T11:13:48+02:00">
    <meta property="article:modified_time" content="2025-07-24T11:13:48+02:00">
    <meta property="article:tag" content="Typescript">
    <meta property="article:tag" content="Meta-Programming">
    <meta property="article:tag" content="Generics">




<link rel="canonical" href="http://www.example.com/posts/parser-types/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css" integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm&#43;MTzNJdv80k&#43;n0=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://www.example.com/">
      djuleayo
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.example.com/posts/parser-types/">
              Parser types
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-07-24T11:13:48&#43;02:00">
                July 24, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/typescript/">Typescript</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/meta-programming/">Meta-Programming</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/generics/">Generics</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="parser-types">
  Parser types
  <a class="heading-link" href="#parser-types">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="intro--formal-languages-and-parsing">
  Intro — formal languages and parsing
  <a class="heading-link" href="#intro--formal-languages-and-parsing">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>All programming languages are specified by a grammar. A grammar tells us whether a piece of text is a valid sentence in that language. A parser generator can take such a grammar and produce a parser. Parsing is the “front end” of compilation: it turns raw text into structure. That’s the basis of how formal languages work.</p>
<p>Simplistic grammar example:</p>
<pre tabindex="0"><code class="language-bison" data-lang="bison">%token &lt;int&gt; NUMBER

expression: expression &#39;+&#39; expression
          | expression &#39;-&#39; expression
          | expression &#39;*&#39; expression
          | expression &#39;/&#39; expression
          | &#39;(&#39; expression &#39;)&#39;
          | NUMBER
          ;
</code></pre><p>This grammar can generate a parser for simple arithmetic. Before parsing, the input is just text. After parsing, we both</p>
<ul>
<li>(a) know whether it’s valid under this grammar and</li>
<li>(b) obtain a structured representation of it.</li>
</ul>
<p>Input:</p>
<pre tabindex="0"><code>1 + 2 * (3 - 4)
</code></pre><p>Parsed tree:</p>
<pre tabindex="0"><code>        +
       / \
      1   *
         / \
        2   -
           / \
          3   4
</code></pre><p>Operator precedence and associativity are encoded in how the tree “leans.” This is an Abstract Syntax Tree (AST). Every program you’ve ever written is, at some level, an AST.</p>
<h2 id="declarative-vs-imperative-why-we-like-trees-as-data">
  Declarative vs. imperative (why we like trees-as-data)
  <a class="heading-link" href="#declarative-vs-imperative-why-we-like-trees-as-data">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>An AST is a tree, and a tree is data. Code can be seen as data laid out in a shape that captures meaning. The tree is a constant shape that other parts of the system can consume. That’s powerful.</p>
<p>Take an Express router:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>router.get(<span style="color:#a5d6ff">&#39;/users&#39;</span>, (req, res) =&gt; {
</span></span><span style="display:flex;"><span>  res.send(<span style="color:#a5d6ff">&#39;Users list&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>You’re not imperatively pushing bytes through sockets; you declare what should happen on /users. The framework consumes that declaration at the right time.</p>
<p>Declarative style usually means: you state what you want; the machinery figures out how. The more capable the machinery, the richer the configuration language must be.</p>
<h2 id="parser-types-1">
  Parser types
  <a class="heading-link" href="#parser-types-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Configurations aren’t always free-form; values often depend on each other. Not every config that “type-checks” at the top level is semantically valid. Think of a configuration as:</p>
<blockquote>
<p>a constant value that must satisfy a language (expressed as an AST)</p></blockquote>
<p>If that clicks, good. TypeScript lets us enforce such languages at compile time. I call these parser types: recursive TS types that act like a grammar. They don’t parse tokens; they constrain shape the way a grammar constrains sentences.</p>
<p>Consider:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Test <span style="color:#ff7b72;font-weight:bold">=</span> Record&lt;<span style="color:#7ee787">string</span>, Test&gt; <span style="color:#8b949e;font-style:italic">// ❌ can&#39;t do
</span></span></span></code></pre></div><p>TS sees a naked, non-terminating recursion and bails.</p>
<p>Even:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Test <span style="color:#ff7b72;font-weight:bold">=</span> Record&lt;<span style="color:#7ee787">string</span>, Test <span style="color:#f85149">|</span> string&gt;
</span></span></code></pre></div><p>still trips the checker.</p>
<p>But:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Test <span style="color:#ff7b72;font-weight:bold">=</span> { 
</span></span><span style="display:flex;"><span>  [key: <span style="color:#ff7b72">string</span>]<span style="color:#ff7b72;font-weight:bold">:</span> Test <span style="color:#ff7b72;font-weight:bold">|</span> <span style="color:#ff7b72">string</span> <span style="color:#8b949e;font-style:italic">// ✅ can do
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><p>works. The index signature form delays evaluation enough for TS to accept the recursion. That’s our recursive hook. Depth is unbounded (until compiler limits), so it can “eat” arbitrarily deep objects. The remaining task is to encode your language rules with unions and recursion.</p>
<p>TypeScript even nudges us syntactically—the leading pipes look exactly like grammar alternatives:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Literal <span style="color:#ff7b72;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> <span style="color:#ff7b72">number</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> <span style="color:#ff7b72">boolean</span>
</span></span><span style="display:flex;"><span>  ;
</span></span></code></pre></div><p>Now, your arithmetic example as a type-level grammar:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Literal_t <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#39;number&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">const</span> ops <span style="color:#ff7b72;font-weight:bold">=</span> [<span style="color:#a5d6ff">&#39;+&#39;</span>, <span style="color:#a5d6ff">&#39;-&#39;</span>, <span style="color:#a5d6ff">&#39;*&#39;</span>, <span style="color:#a5d6ff">&#39;/&#39;</span>] <span style="color:#ff7b72">as</span> <span style="color:#ff7b72">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Op <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">typeof</span> ops[<span style="color:#ff7b72">number</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 1) leaf
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">interface</span> NumberLiteral {
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;number&#39;</span>;
</span></span><span style="display:flex;"><span>  value: <span style="color:#ff7b72">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 2) binary
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">interface</span> BinaryExpr {
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;binary&#39;</span>;
</span></span><span style="display:flex;"><span>  op: <span style="color:#ff7b72">Op</span>;
</span></span><span style="display:flex;"><span>  left: <span style="color:#ff7b72">Expression</span>;
</span></span><span style="display:flex;"><span>  right: <span style="color:#ff7b72">Expression</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 3) grouping
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">interface</span> ParenExpr {
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;group&#39;</span>;
</span></span><span style="display:flex;"><span>  expression: <span style="color:#ff7b72">Expression</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 4) the one non-recursive alias
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">export</span> <span style="color:#ff7b72">type</span> Expression <span style="color:#ff7b72;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> NumberLiteral
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> BinaryExpr
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72;font-weight:bold">|</span> ParenExpr
</span></span><span style="display:flex;"><span>  ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// type annotation assures the object matches the grammar as AST
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">const</span> ast: <span style="color:#ff7b72">Expression</span> <span style="color:#ff7b72;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;binary&#39;</span>,
</span></span><span style="display:flex;"><span>  op<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;+&#39;</span>,
</span></span><span style="display:flex;"><span>  left<span style="color:#ff7b72;font-weight:bold">:</span> { <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;number&#39;</span>, value: <span style="color:#ff7b72">1</span> },
</span></span><span style="display:flex;"><span>  right<span style="color:#ff7b72;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;binary&#39;</span>,
</span></span><span style="display:flex;"><span>    test<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;asdf&#39;</span>, <span style="color:#8b949e;font-style:italic">// ❌ type error
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    op<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;*&#39;</span>,
</span></span><span style="display:flex;"><span>    left<span style="color:#ff7b72;font-weight:bold">:</span> { <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;number&#39;</span>, value: <span style="color:#ff7b72">2</span> },
</span></span><span style="display:flex;"><span>    right<span style="color:#ff7b72;font-weight:bold">:</span> { <span style="color:#ff7b72">type</span><span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#39;number&#39;</span>, value: <span style="color:#ff7b72">3</span> },
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>That stray test: &lsquo;asdf&rsquo; is illegal under the grammar and TypeScript tells you immediately. Bonus: editor autocomplete now “knows” exactly what belongs where in your config/AST.</p>
<h2 id="why-would-you-care">
  Why would you care?
  <a class="heading-link" href="#why-would-you-care">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Already mentioned: grammar can check more then any type union can.
But another area is COMPOSITE PATTERN constants. IE JSX is composite.
Child of a node is again JSX node. Composite patterns are omnipresent yet
constants of composite patterns are very error prone. Especially written by hand
without assistance of language server. Now JSX is solved as it is. Syntax sugar
for function calls. Thats runtime in essence and not a constant.</p>
<p>I&rsquo;ll hint another example of composite that with some effort of defining
proper &ldquo;parser type&rdquo;, we can declare as constants with full type support.
Server routers. They are composable. and leafs are controllers.
Such constant would be SSOT which is effectively shared contract between server and client.
Out of the box both api client and controller functions would have full type support.
You can say, well we can use open API spec for that. But such a type would
allow full type support just out of declaration and nothing more. No generate types
step, code gen, eventual DRY hell retyping schemas and so on.
In next post I&rsquo;ll show how to do that with a real example. Stay tuned.</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "djuleayo" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2025
     djuleayo 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script defer data-domain="djuleayo.com" src="https://plausible.io/js/script.js"></script>

</body>
</html>
