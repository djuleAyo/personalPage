<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
   · djuleayo
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="djuleayo">
<meta name="description" content="Some languages support traits. Traits are trivially implemented interfaces.
So you have a zero interface and you trivially implement it simply by
annotating it. This is interesting scenario that points directly to more fancy
languages and language features like rust, haskell, scala etc.
Those functional beasts go into limitations of human comprehension which quickly
declines with rising level of abstraction. But traits, as I see it is a widely
accepted concept throughout the programming world.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="djuleayo">
  <meta name="twitter:description" content="Some languages support traits. Traits are trivially implemented interfaces. So you have a zero interface and you trivially implement it simply by annotating it. This is interesting scenario that points directly to more fancy languages and language features like rust, haskell, scala etc. Those functional beasts go into limitations of human comprehension which quickly declines with rising level of abstraction. But traits, as I see it is a widely accepted concept throughout the programming world.">

<meta property="og:url" content="http://localhost:1313/posts/draft-trait-structure/">
  <meta property="og:site_name" content="djuleayo">
  <meta property="og:title" content="djuleayo">
  <meta property="og:description" content="Some languages support traits. Traits are trivially implemented interfaces. So you have a zero interface and you trivially implement it simply by annotating it. This is interesting scenario that points directly to more fancy languages and language features like rust, haskell, scala etc. Those functional beasts go into limitations of human comprehension which quickly declines with rising level of abstraction. But traits, as I see it is a widely accepted concept throughout the programming world.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-24T14:58:17+02:00">
    <meta property="article:modified_time" content="2025-06-24T14:58:17+02:00">




<link rel="canonical" href="http://localhost:1313/posts/draft-trait-structure/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 




<link rel="icon" type="image/svg+xml" href="/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      djuleayo
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/draft-trait-structure/">
              
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-06-24T14:58:17&#43;02:00">
                June 24, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              3-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div class="post-content">
        
        <p>Some languages support traits. Traits are trivially implemented interfaces.
So you have a <strong>zero</strong> interface and you trivially implement it simply by
annotating it. This is interesting scenario that points directly to more fancy
languages and language features like rust, haskell, scala etc.
Those functional beasts go into limitations of human comprehension which quickly
declines with rising level of abstraction. But traits, as I see it is a widely
accepted concept throughout the programming world.</p>
<p>So what do traits allow us? In essence you can declare what a trait and implement
it elsewhere. Or not implement it at all.
As trait is a zero interface, name of the trait is only carrier of information.
And those names are organized in trait hierarchies as traits can extend other traits.</p>
<p>If you imagine simple tag system like you have in <em>youtube</em> lets say:
music, games, sports, etc
Its clear the intent of those tags but in more complex scenarios:</p>
<p>email could be:</p>
<ul>
<li>a regex</li>
<li>scalar type</li>
<li>string</li>
<li>a property of an object</li>
</ul>
<p>such a tag is ambiguous and would make a good use of hierarchical disambiguation.</p>
<ul>
<li>user/email</li>
<li>scalar/email</li>
<li>input/email</li>
</ul>
<p>Maybe the example could be even more illustrative, but I think you get the point.
I used path to disambiguate and path is exactly what matches a position in a tree.</p>
<p>So you could use traits for structured tags. While vectors of data indexing have abstract meaning
for its coordinates, structured tags have binary outcome. And inheritance included</p>
<p>With this setup in mind we can say a document has a signature.
Signature is binary vector of traits that are organized in hierarchies.</p>
<p>Here we come to a great use of roaring bitmaps.</p>
<p>Sad times of vibe coding have come and even among developers I recon alarming number of them
has no clue what a bit map is. Let alone roaring bitmaps. But worry  not if you dont. I leaving
you breadcrumbs to follow. In this post I provided highly inlustrative example for use of
bitmaps. But back to exciting stuff.</p>
<p>Roaring bitmap and be used as a signature of a document where each bit is a trait.</p>
<p>Roaring bitmap provides efficient set operations and optimization of encoding.
Freaquently used traits can be ordered on vector positions so that operations are faster.
Aint that great?</p>
<p>And here comes the crown. In such setup I described, where you used multihierarchical tags/labels
bits of roaring bitmap to sign documents, great way to provide highly intuitive UX would be based
of partial ordering of subsets.</p>
<p>Lets give few definitions:</p>
<p>Fragment is all documents that are under the same signature.</p>
<p>We would like in almost constant time to know ordering in sense of subset between fragments.</p>
<p>So final structure is a tree of fragments where each fragment is a set of documents with that
signature. Fragments on same branch (path) of a tree are edit distance 1 apart.</p>
<p>Such a tree gives us</p>
<ul>
<li>graph fragmentation in its components</li>
<li>efficient set operations on fragments</li>
</ul>
<p>And is in essence deterministic structure for data indexing.
While many kinds of data in fact need indexing that is abstract in its coordinates,
like pictures and text, anything exact, IE entire codebases could and should be indexed
in relational manner instead of nominal as each document in fact is looked in many
different hierarchies out of which none can be declared as primary.</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "djuleayo" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2025
     djuleayo 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script defer data-domain="djuleayo.com" src="https://plausible.io/js/script.js"></script>

</body>
</html>
